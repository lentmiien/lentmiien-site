extends layout

block content
  .row
    .col-lg-8
      h1.mb-3 Embedding API Test
      p.text-muted.mb-4
        | API base:
        code.ms-1= apiBase
        | . Send sample text(s) to the /embed endpoint (max #{maxTexts} per request).

      if error
        .alert.alert-danger(role="alert")= error
      if info
        .alert.alert-info(role="alert")= info

      form.card.mb-4(method="post", action="/admin/embedding-test")
        .card-body
          .mb-3
            label.form-label(for="text") Text
            textarea#text.form-control(name="text", rows="5", required, placeholder="Enter text to embed")= form.text
            small.form-text.text-muted Use split mode below to send multiple texts at once.
          .mb-3
            label.form-label.d-block(for="split_mode") Split mode
            .d-flex.flex-wrap.align-items-center.gap-3
              .form-check.form-check-inline
                input#split_single.form-check-input(type="radio", name="split_mode", value="single", checked=form.splitMode !== 'lines')
                label.form-check-label(for="split_single") Single block
              .form-check.form-check-inline
                input#split_lines.form-check-input(type="radio", name="split_mode", value="lines", checked=form.splitMode === 'lines')
                label.form-check-label(for="split_lines") One text per line
            small.form-text.text-muted Max #{maxTexts} texts per request.
          .mb-3
            .form-check.form-switch
              input#auto_chunk.form-check-input(type="checkbox", name="auto_chunk", checked=form.autoChunk)
              label.form-check-label(for="auto_chunk") auto_chunk (let the API chunk automatically)
            small.form-text.text-muted Uncheck to send the raw text without auto chunking.
          .row
            .col-md-6.mb-3
              label.form-label(for="max_tokens_per_chunk") max_tokens_per_chunk
              input#max_tokens_per_chunk.form-control(type="number", name="max_tokens_per_chunk", min="1", step="1", value=form.maxTokensPerChunk === '' ? '' : form.maxTokensPerChunk)
              small.form-text.text-muted Leave blank to use the API default.
            .col-md-6.mb-3
              label.form-label(for="overlap_tokens") overlap_tokens
              input#overlap_tokens.form-control(type="number", name="overlap_tokens", min="0", step="1", value=form.overlapTokens === '' ? '' : form.overlapTokens)
              small.form-text.text-muted Default #{defaultOverlap}; leave blank to use the API default.
          button.btn.btn-primary(type="submit") Generate embeddings

      if result
        .card.mb-4
          .card-body
            h5.mb-3 Response
            .d-flex.flex-wrap.gap-3.align-items-center.mb-2
              span.badge.text-bg-success= result.model || 'unknown model'
              span.badge.text-bg-light.text-secondary Dim #{result.dim || 'N/A'}
              span.badge.text-bg-light.text-secondary= `${(result.vectors && result.vectors.length) || 0} vector(s)`
              span.badge.text-bg-light.text-secondary= `${(result.chunks && result.chunks.length) || 0} chunk(s)`
            if submittedTexts && submittedTexts.length
              h6.mt-2.mb-2 Sent texts
              ul.mb-3
                each t, idx in submittedTexts
                  if idx < 3
                    li
                      span.fw-semibold= `#${idx + 1} `
                      | #{t.length > 200 ? `${t.slice(0, 200)}…` : t}
                if submittedTexts.length > 3
                  li.text-muted= `+${submittedTexts.length - 3} more`
            if result.chunks && result.chunks.length
              h6.mt-3.mb-2 Chunk details
              table.table.table-sm
                thead
                  tr
                    th #
                    th text_index
                    th chunk_index
                    th tokens
                    th length
                tbody
                  each chunk, idx in result.chunks
                    tr
                      td= idx + 1
                      td= chunk.text_index
                      td= chunk.chunk_index
                      td= `${chunk.start_token} - ${chunk.end_token}`
                      td= chunk.end_token - chunk.start_token
            if result.vectors && result.vectors.length
              - const firstVector = Array.isArray(result.vectors[0]) ? result.vectors[0] : [];
              h6.mt-3.mb-1 First vector preview
              p.text-muted.mb-1= `Showing first ${Math.min(firstVector.length, 12)} values from chunk 0`
              code.d-block= JSON.stringify(firstVector.slice(0, 12))
            details.mt-3
              summary Raw response
              pre.small= JSON.stringify(result, null, 2)
      else
        .card
          .card-body
            h6.mb-2 Response
            p.text-muted.mb-0 Submit text above to see embeddings.
      form.card.mb-4(method="post", action="/admin/embedding-test/search")
        .card-body
          h5.mb-3 Search stored embeddings
          p.text-muted.small.mb-3 Search uses the latest stored vectors in MongoDB. Results show metadata to help you find the source record.
          .mb-3
            label.form-label(for="search_text") Query text
            textarea#search_text.form-control(name="search_text", rows="3", required, placeholder="Enter text to search for similar embeddings")= searchForm && searchForm.query
          .mb-3
            label.form-label(for="search_type") Search type
            select#search_type.form-select(name="search_type")
              each option in searchTypes
                option(value=option.value, selected=searchForm && searchForm.searchType === option.value)= option.label
            small.form-text.text-muted Choose which embedding store or strategy to use.
          .row
            .col-md-6.mb-3
              label.form-label(for="start_date") Updated start date
              input#start_date.form-control(type="date", name="start_date", value=searchForm && searchForm.startDate ? searchForm.startDate : '')
              small.form-text.text-muted Inclusive; leave blank for no minimum.
            .col-md-6.mb-3
              label.form-label(for="end_date") Updated end date
              input#end_date.form-control(type="date", name="end_date", value=searchForm && searchForm.endDate ? searchForm.endDate : '')
              small.form-text.text-muted Inclusive; leave blank for no maximum.
          .mb-3
            label.form-label(for="top_k") Results to return
            input#top_k.form-control(type="number", name="top_k", min="1", max=searchLimits && searchLimits.maxTopK ? searchLimits.maxTopK : 50, value=searchForm && searchForm.topK !== undefined ? searchForm.topK : (searchLimits && searchLimits.defaultTopK ? searchLimits.defaultTopK : 10))
            small.form-text.text-muted= `Between 1 and ${(searchLimits && searchLimits.maxTopK) || 50} results`
          button.btn.btn-secondary(type="submit") Search embeddings
      if searchError
        .alert.alert-danger(role="alert")= searchError
      if searchResult
            .card.mb-4
              .card-body
                h5.mb-3 Search results
                .d-flex.flex-wrap.gap-3.align-items-center.mb-3
                  span.badge.text-bg-light.text-secondary= `${(searchResult.results && searchResult.results.length) || 0} match(es)`
                  span.badge.text-bg-light.text-secondary Dim #{searchResult.dim || 'unknown'}
                  if searchResult.model
                    span.badge.text-bg-light.text-secondary= searchResult.model
                  if searchResult.modeLabel
                    span.badge.text-bg-info= searchResult.modeLabel
                  else if searchResult.mode
                    span.badge.text-bg-info= searchResult.mode
                  if searchResult.apiBase
                    span.badge.text-bg-light.text-secondary= searchResult.apiBase
                  if searchResult.reranked
                    span.badge.text-bg-warning.text-dark Reranked
                  if searchForm && (searchForm.startDate || searchForm.endDate)
                    span.badge.text-bg-light.text-secondary= `Updated ${searchForm.startDate || 'start'} -> ${searchForm.endDate || 'now'}`
                p.text-muted.small.mt-n1.mb-3 Showing unique entries per source/parent; dates filter by updatedAt (UTC).
                if searchResult.results && searchResult.results.length
                  each row, idx in searchResult.results
                    .border.rounded-3.p-3.mb-3
                      .d-flex.justify-content-between.align-items-center.mb-2
                        span.fw-semibold= `#${idx + 1}`
                        span.badge.text-bg-primary= (row.similarity !== undefined && row.similarity !== null) ? row.similarity.toFixed(4) : '0.0000'
                      - const previewText = row.previewText || '';
                      p.mb-2= previewText ? (previewText.length > 360 ? `${previewText.slice(0, 360)}…` : previewText) : 'No preview available.'
                      ul.list-unstyled.small.mb-0
                        - const isOcrFile = row.source && row.source.collectionName === 'ocr_job_files';
                        - const ocrJobId = row.source && (row.source.parentId || row.source.parent_id);
                        - const ocrFileId = row.source && (row.source.documentId || row.source.document_id);
                        - const isKnowledge = row.source && row.source.collectionName === 'knowledge';
                        - const knowledgeId = row.source && (row.source.documentId || row.source.document_id);
                        - const isChat = row.source && row.source.collectionName === 'chat_message';
                        - const conversationId = row.source && (row.source.parentId || row.source.parent_id);
                        - const isASR = row.source && row.source.collectionName === 'asr_jobs';
                        - const asrId = row.source && (row.source.parentId || row.source.parent_id);
                        li
                          strong Source:
                          |  #{row.source && row.source.collectionName ? row.source.collectionName : 'n/a'} · #{row.source && row.source.documentId ? row.source.documentId : 'n/a'}
                        if row.source && (row.source.parentCollection || row.source.parentId)
                          li
                            strong Parent:
                            |  #{row.source.parentCollection || 'n/a'} · #{row.source.parentId || 'n/a'}
                        if isOcrFile && ocrJobId
                          - const ocrHref = ocrFileId ? `/ocr/jobs/${ocrJobId}/view/${ocrFileId}` : `/ocr/jobs/${ocrJobId}/view`;
                          li
                            strong OCR job:
                            |  
                            a(href=ocrHref, target="_blank", rel="noreferrer") View job page
                        if isKnowledge && knowledgeId
                          - const knowledgeHref = `/chat4/viewknowledge/${knowledgeId}`;
                          li
                            strong Knowledge:
                            |  
                            a(href=knowledgeHref, target="_blank", rel="noreferrer") View knowledge
                        if isChat && conversationId
                          - const chatHref = `/chat5/chat/${conversationId}`;
                          li
                            strong Chat:
                            |  
                            a(href=chatHref, target="_blank", rel="noreferrer") View chat
                        if isASR && asrId
                          - const asrHref = `/asr/job/${asrId}`;
                          li
                            strong ASR job:
                            |  
                            a(href=asrHref, target="_blank", rel="noreferrer") View job
                        li
                          strong Content type:
                          |  #{row.source && row.source.contentType ? row.source.contentType : 'n/a'}
                        li
                          strong Chunk:
                          |  text #{row.chunk && row.chunk.textIndex !== undefined ? row.chunk.textIndex : 0}, chunk #{row.chunk && row.chunk.chunkIndex !== undefined ? row.chunk.chunkIndex : 0}, tokens #{row.chunk && row.chunk.startToken !== undefined ? row.chunk.startToken : 0} - #{row.chunk && row.chunk.endToken !== undefined ? row.chunk.endToken : 0}
                        if row.dim
                          li
                            strong Dim:
                            |  #{row.dim}
                        if row.model || searchResult.model
                          li
                            strong Model:
                            |  #{row.model || searchResult.model}
                        if row.rerank && row.rerank.baseSimilarity !== undefined
                          - const baseScore = Number.isFinite(row.rerank.baseSimilarity) ? row.rerank.baseSimilarity.toFixed(4) : row.rerank.baseSimilarity;
                          li
                            strong Base similarity:
                            |  #{baseScore}
                        li
                          strong Updated:
                          |  #{row.updatedAt ? new Date(row.updatedAt).toLocaleString() : 'n/a'}
                else
                  p.text-muted.mb-0 No matches found yet. Run a search above.
      else
        .card
          .card-body
            h6.mb-2 Search results
            p.text-muted.mb-0 Submit a query above to search stored embeddings.
    .col-lg-4
      .card.mb-3
        .card-body
          h5.mb-2 API health
          p.mb-1
            strong Base:
            code.ms-1= apiBase
          if highQualityApiBase
            p.mb-1
              strong High-quality:
              code.ms-1= highQualityApiBase
          if health
            p.mb-2
              strong Status:
              if health.status && health.status.toLowerCase() === 'ok'
                span.text-success.ms-1= health.status
              else
                span.text-warning.ms-1= health.status || 'unknown'
            if health.model
              p.mb-1
                strong Model:
                span.ms-1= health.model
            if health.model_max_tokens
              p.mb-1
                strong model_max_tokens:
                span.ms-1= health.model_max_tokens
            p.mb-0.text-muted
              | cuda: #{health.cuda ? 'true' : 'false'}, on-demand GPU: #{health.use_on_demand_gpu ? 'true' : 'false'}
          else if healthError
            .alert.alert-warning.mb-0(role="alert")= healthError
          else
            p.text-muted.mb-0 No health data yet.
      .card
        .card-body
          h5.mb-2 Request options
          p.mb-1
            strong auto_chunk:
            span.ms-1= requestOptions && requestOptions.autoChunk ? 'true' : 'false'
          p.mb-1
            strong max_tokens_per_chunk:
            span.ms-1= requestOptions && requestOptions.maxTokensPerChunk !== undefined && requestOptions.maxTokensPerChunk !== null && requestOptions.maxTokensPerChunk !== '' ? requestOptions.maxTokensPerChunk : 'default'
          p.mb-0
            strong overlap_tokens:
            span.ms-1= requestOptions && requestOptions.overlapTokens !== undefined && requestOptions.overlapTokens !== null && requestOptions.overlapTokens !== '' ? requestOptions.overlapTokens : 'default'
