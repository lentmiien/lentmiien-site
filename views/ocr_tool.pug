extends layout

block styles
  style.
    :root {
      --ocr-bg: #0E0F13;
      --ocr-surface-1: #171A20;
      --ocr-surface-2: #1B2026;
      --ocr-surface-3: #20242A;
      --ocr-border: #262B34;
      --ocr-divider: #2B313C;
      --ocr-text: #E8ECF2;
      --ocr-text-secondary: #C1C7D3;
      --ocr-text-muted: #9AA3B2;
      --ocr-brand: #FF6A1F;
      --ocr-brand-hover: #FF7C3B;
      --ocr-brand-active: #E05F1C;
      --ocr-accent: #FFC247;
      --ocr-accent-hover: #FFD36F;
      --ocr-success: #17C696;
      --ocr-warning: #FFC63D;
      --ocr-danger: #FF4D4F;
      --ocr-focus: #FFC247;
    }

    .ocr-page {
      background: var(--ocr-bg);
      color: var(--ocr-text);
      border-radius: 24px;
      padding: 2rem;
      margin: 1rem 0 3rem;
      box-shadow: 0 50px 120px rgba(0, 0, 0, 0.35);
    }

    .ocr-header h1 {
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .ocr-header p {
      color: var(--ocr-text-secondary);
      max-width: 900px;
      margin-bottom: 1.5rem;
    }

    .ocr-status {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.6rem 0.9rem;
      border-radius: 999px;
      background: var(--ocr-surface-2);
      border: 1px solid var(--ocr-border);
      color: var(--ocr-text-secondary);
      margin-bottom: 1rem;
    }

    .ocr-status .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .ocr-status.is-ok .dot {
      background: var(--ocr-success);
    }

    .ocr-status.is-warn .dot {
      background: var(--ocr-warning);
    }

    .ocr-grid {
      display: grid;
      grid-template-columns: minmax(0, 360px) minmax(0, 1fr);
      gap: 1.5rem;
    }

    .ocr-grid.is-single {
      grid-template-columns: 1fr;
    }

    @media (max-width: 1200px) {
      .ocr-grid {
        grid-template-columns: 1fr;
      }
    }

    .ocr-card {
      background: var(--ocr-surface-1);
      border: 1px solid var(--ocr-border);
      border-radius: 18px;
      padding: 1.5rem;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.01);
    }

    .ocr-card + .ocr-card {
      margin-top: 1.25rem;
    }

    .ocr-card h2,
    .ocr-card h3 {
      margin-bottom: 0.75rem;
      font-weight: 600;
    }

    .ocr-form label {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--ocr-text-muted);
      margin-bottom: 0.4rem;
    }

    .ocr-form input,
    .ocr-form textarea {
      width: 100%;
      background: var(--ocr-surface-2);
      border: 1px solid var(--ocr-border);
      color: var(--ocr-text);
      border-radius: 10px;
      padding: 0.75rem;
      font-size: 0.95rem;
    }

    .ocr-form textarea {
      min-height: 120px;
      resize: vertical;
    }

    .ocr-form input:focus,
    .ocr-form textarea:focus {
      outline: 2px solid var(--ocr-focus);
      border-color: var(--ocr-focus);
    }

    .ocr-form button {
      margin-top: 1rem;
      width: 100%;
      border: none;
      border-radius: 999px;
      padding: 0.85rem;
      background: var(--ocr-brand);
      color: #111418;
      font-weight: 600;
      transition: background 0.2s ease;
    }

    .ocr-form button:hover {
      background: var(--ocr-brand-hover);
    }

    .ocr-form button:active {
      background: var(--ocr-brand-active);
    }

    .job-list-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
    }

    .job-list-header span {
      color: var(--ocr-text-muted);
      font-size: 0.85rem;
    }

    .job-rows {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .job-row {
      border: 1px solid var(--ocr-border);
      border-radius: 12px;
      padding: 0.85rem;
      background: var(--ocr-surface-2);
      color: inherit;
      width: 100%;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      transition: border-color 0.2s ease, transform 0.2s ease;
    }

    .job-row:hover {
      border-color: var(--ocr-accent);
      transform: translateX(2px);
    }

    .job-row.is-active {
      border-color: var(--ocr-brand);
      box-shadow: 0 0 0 1px var(--ocr-brand);
    }

    .job-list-footer {
      margin-top: 0.75rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      align-items: center;
    }

    .job-toolbar {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
    }

    .pill-button {
      border: 1px solid var(--ocr-border);
      background: transparent;
      color: var(--ocr-text);
      padding: 0.55rem 0.9rem;
      border-radius: 999px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
    }

    .pill-button.is-ghost {
      color: var(--ocr-text-secondary);
    }

    .pill-button.is-danger {
      border-color: var(--ocr-danger);
      color: var(--ocr-danger);
    }

    .pill-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .job-row .job-status-line {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .status-badge {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      border: 1px solid transparent;
    }

    .status-queued {
      border-color: var(--ocr-border);
      color: var(--ocr-text-muted);
    }

    .status-processing {
      border-color: var(--ocr-warning);
      color: var(--ocr-warning);
    }

    .status-completed {
      border-color: var(--ocr-success);
      color: var(--ocr-success);
    }

    .status-failed {
      border-color: var(--ocr-danger);
      color: var(--ocr-danger);
    }

    .job-row .job-meta-line {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--ocr-text-muted);
    }

    .job-empty-state {
      background: var(--ocr-surface-2);
      border-radius: 12px;
      padding: 1rem;
      border: 1px dashed var(--ocr-border);
      color: var(--ocr-text-muted);
      text-align: center;
    }

    .job-details-header {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    .job-meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .meta-block {
      background: var(--ocr-surface-2);
      border: 1px solid var(--ocr-border);
      border-radius: 12px;
      padding: 0.75rem;
    }

    .meta-label {
      font-size: 0.75rem;
      color: var(--ocr-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .meta-value {
      font-weight: 600;
      margin-top: 0.3rem;
      word-break: break-word;
    }

    .job-prompt-block {
      background: var(--ocr-surface-2);
      border: 1px solid var(--ocr-border);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }

    .job-prompt-block pre {
      margin: 0;
      color: var(--ocr-text);
      white-space: pre-wrap;
    }

    .job-error {
      margin-top: 0.5rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(255, 77, 79, 0.09);
      border: 1px solid rgba(255, 77, 79, 0.4);
      color: var(--ocr-danger);
    }

    .file-card {
      border: 1px solid var(--ocr-border);
      border-radius: 16px;
      padding: 1.25rem;
      background: var(--ocr-surface-2);
      margin-bottom: 1.25rem;
    }

    .file-card.is-highlighted {
      border-color: var(--ocr-accent);
      box-shadow: 0 0 0 1px var(--ocr-accent), 0 16px 40px rgba(255, 194, 71, 0.08);
    }

    .file-card h4 {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .file-meta {
      color: var(--ocr-text-muted);
      font-size: 0.85rem;
      margin-bottom: 1rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .file-error {
      margin-top: 0.75rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(255, 77, 79, 0.09);
      border: 1px dashed rgba(255, 77, 79, 0.5);
      color: var(--ocr-danger);
    }

    .image-stage {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #020305;
      border: 1px solid var(--ocr-border);
    }

    .image-stage img {
      display: block;
      width: 100%;
      height: auto;
    }

    .box-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .bounding-box {
      position: absolute;
      border: 2px solid rgba(255, 106, 31, 0.9);
      background: rgba(255, 106, 31, 0.16);
      border-radius: 8px;
      pointer-events: auto;
      transition: border-color 0.2s ease;
    }

    .bounding-box:hover {
      border-color: var(--ocr-accent);
      background: rgba(255, 194, 71, 0.18);
      z-index: 5;
    }

    .bounding-box .box-label {
      position: absolute;
      top: 100%;
      left: 0;
      transform: translateY(6px);
      background: rgba(32, 36, 42, 0.95);
      color: var(--ocr-text);
      padding: 0.35rem 0.5rem;
      border-radius: 6px;
      font-size: 0.75rem;
      max-width: 260px;
      opacity: 0;
      pointer-events: none;
      white-space: pre-wrap;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .bounding-box:hover .box-label {
      opacity: 1;
      transform: translateY(0);
    }

    .text-card {
      background: var(--ocr-surface-3);
      border-radius: 14px;
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--ocr-border);
    }

    .text-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .copy-btn {
      background: transparent;
      border: 1px solid var(--ocr-accent);
      color: var(--ocr-accent);
      border-radius: 999px;
      font-size: 0.85rem;
      padding: 0.25rem 0.75rem;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .copy-btn:hover {
      background: rgba(255, 194, 71, 0.15);
      color: var(--ocr-text);
    }

    .text-card pre {
      margin: 0;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 0.85rem;
      color: var(--ocr-text-secondary);
      max-height: 320px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .layout-textarea {
      width: 100%;
      min-height: 180px;
      background: var(--ocr-surface-1);
      border: 1px solid var(--ocr-border);
      border-radius: 10px;
      color: var(--ocr-text);
      padding: 0.75rem;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      resize: vertical;
    }

    .layout-textarea:focus {
      outline: 2px solid var(--ocr-focus);
      border-color: var(--ocr-focus);
    }

    .edit-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 0.5rem;
    }

    .save-edits-btn {
      border: none;
      background: var(--ocr-accent);
      color: #111418;
      padding: 0.6rem 0.95rem;
      border-radius: 10px;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .save-edits-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .restore-edits-btn {
      border: 1px solid var(--ocr-border);
      background: transparent;
      color: var(--ocr-text-secondary);
      padding: 0.6rem 0.95rem;
      border-radius: 10px;
      margin-left: 0.5rem;
      cursor: pointer;
    }

    .segment-editor {
      border: 1px solid var(--ocr-border);
      background: var(--ocr-surface-2);
      padding: 0.75rem;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .segment-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 0.5rem;
      align-items: center;
    }

    .segment-input input {
      width: 100%;
      background: var(--ocr-surface-3);
      border: 1px solid var(--ocr-border);
      border-radius: 8px;
      padding: 0.5rem;
      color: var(--ocr-text);
    }

    .segment-coords {
      color: var(--ocr-text-muted);
      font-size: 0.8rem;
      margin-top: 0.25rem;
    }

    .segment-remove {
      border: 1px solid var(--ocr-danger);
      background: transparent;
      color: var(--ocr-danger);
      border-radius: 8px;
      padding: 0.4rem 0.75rem;
      cursor: pointer;
    }

    .segment-remove:hover {
      background: rgba(255, 77, 79, 0.12);
    }

    .job-actions {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      margin-bottom: 1.25rem;
    }

    .forward-btn {
      border: none;
      border-radius: 999px;
      padding: 0.85rem 1rem;
      background: var(--ocr-accent);
      color: #111418;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      transition: background 0.2s ease, transform 0.1s ease;
    }

    .forward-btn:hover:enabled {
      background: var(--ocr-accent-hover);
      transform: translateY(-1px);
    }

    .forward-btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      background: var(--ocr-border);
      color: var(--ocr-text-muted);
    }

    #ocrFeedback {
      margin-top: 1rem;
      min-height: 1.5rem;
      font-size: 0.9rem;
    }

    #ocrFeedback span {
      padding: 0.5rem 0.75rem;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    #ocrFeedback .is-success {
      background: rgba(23, 198, 150, 0.18);
      color: var(--ocr-success);
    }

    #ocrFeedback .is-error {
      background: rgba(255, 77, 79, 0.18);
      color: var(--ocr-danger);
    }

    #ocrFeedback .is-info {
      background: rgba(255, 194, 71, 0.18);
      color: var(--ocr-accent);
    }

    .ocr-note {
      font-size: 0.85rem;
      color: var(--ocr-text-muted);
      margin-top: 0.5rem;
    }

block content
  .ocr-page
    .ocr-header
      h1 OCR workspace
      p Harness the on-prem OCR stack with queued jobs, multi-image batches, and bounding-box visualization. Upload images, let the queue work in the background, and explore every job once it completes.
    if health
      .ocr-status(class=health.status === 'ok' ? 'is-ok' : 'is-warn')
        span.dot
        span Service #{health.status} · Model #{health.model || 'n/a'}
    else
      .ocr-status.is-warn
        span.dot
        span Unable to reach OCR health endpoint. Results might be unavailable.
    .ocr-grid(class=singleJobMode ? 'is-single' : '')
      if !singleJobMode
        .ocr-left
          .ocr-card
            h2 Submit images
            p.ocr-note The request will be queued; each file is processed sequentially with the same prompt and token limit.
            form#ocrForm.ocr-form(method='post', action='/ocr/jobs', enctype='multipart/form-data')
              label(for='images') Image files
              input#images(type='file', name='images', accept='image/*', multiple, required)
              label(for='max_new_tokens') Max new tokens
              input#max_new_tokens(type='number', name='max_new_tokens', min='1', max=tokenLimit, value=formValues.maxNewTokens, required)
              label(for='prompt') Prompt
              textarea#prompt(name='prompt')= formValues.prompt
              button(type='submit') Queue OCR job
            p.ocr-note Upload limit: #{process.env.OCR_JOB_MAX_FILES || 5} files · 25MB each
          .ocr-card
            .job-list-header
              h2 Job history
              span#jobCount
            p.ocr-note#jobRangeNote Showing the last 7 days of OCR jobs. Load older jobs to browse further back.
            #ocrJobList.job-rows
              if jobs && jobs.length
                each job in jobs
                  button.job-row(type='button', data-job-id=job.id)
                    .job-status-line
                      span.status-badge(class=`status-${job.status}`)= job.status
                      span= `${job.files.filter(f => f.status === 'completed').length}/${job.files.length} files`
                    .job-meta-line
                      span= new Date(job.createdAt).toLocaleTimeString()
                      span= job.owner && job.owner.name ? job.owner.name : 'You'
              else
                .job-empty-state
                  span No jobs yet. Upload files to kick things off.
            .job-list-footer
              button#loadOlderJobs.pill-button.is-ghost(type='button') Load older jobs
      .ocr-right
        .ocr-card
          .job-details-header
            h2 Job details
            span.text-muted#jobStatusLabel
          .job-toolbar
            button#refreshJobBtn.pill-button.is-ghost(type='button') Refresh
            button#deleteJobBtn.pill-button.is-danger(type='button') Delete entry
          #ocrJobDetails
            if singleJobMode
              p.text-muted Loading job details...
            else
              p.text-muted Select a job from the queue to view its status and results.
    #ocrFeedback(aria-live='polite')
    noscript
      .alert.alert-warning.mb-0 This tool requires JavaScript to manage jobs and fetch results. Please enable JavaScript in your browser.

block script
  script.
    window.__INITIAL_JOBS__ = !{JSON.stringify(jobs || [])};
    window.__INITIAL_JOBS_LAST_UPDATED__ = !{JSON.stringify(latestUpdatedAt || null)};
    window.__INITIAL_HAS_OLDER__ = !{JSON.stringify(hasOlder || false)};
    window.__OCR_SINGLE_JOB_MODE__ = !{JSON.stringify(Boolean(singleJobMode))};
    window.__OCR_SINGLE_JOB_ID__ = !{JSON.stringify(selectedJobId || null)};
    window.__OCR_SINGLE_JOB_DETAIL__ = !{JSON.stringify(initialJobDetail || null)};
    window.__OCR_HIGHLIGHT_FILE_ID__ = !{JSON.stringify(highlightFileId || null)};
  script.
    (() => {
      const JOBS_ENDPOINT = '/ocr/jobs';
      const RECEIPT_ENDPOINT = '/receipt/upload_receipt';
      const FAST_POLL_MS = 5000;
      const SLOW_POLL_MS = 10000;
      const SINGLE_JOB_ID = window.__OCR_SINGLE_JOB_ID__ || null;
      const singleJobMode = Boolean(window.__OCR_SINGLE_JOB_MODE__);
      const initialJobDetail = window.__OCR_SINGLE_JOB_DETAIL__;
      const highlightFileId = typeof window.__OCR_HIGHLIGHT_FILE_ID__ === 'string'
        ? window.__OCR_HIGHLIGHT_FILE_ID__
        : null;
      const state = {
        jobs: Array.isArray(window.__INITIAL_JOBS__) ? window.__INITIAL_JOBS__ : [],
        jobDetails: {},
        selectedJobId: SINGLE_JOB_ID || null,
        isSubmitting: false,
        pollTimer: null,
        isForwarding: false,
        isEditingLayout: false,
        latestUpdatedAt: typeof window.__INITIAL_JOBS_LAST_UPDATED__ === 'string'
          ? window.__INITIAL_JOBS_LAST_UPDATED__
          : null,
        isFetchingJobs: false,
        hasOlder: singleJobMode ? false : Boolean(window.__INITIAL_HAS_OLDER__),
        oldestLoaded: null,
        detailLoading: {},
        savingEdits: {},
        loadingOlder: false,
        deletingJob: false,
        highlightFileId,
        didScrollToHighlight: false,
        singleJobMode,
      };

      const jobListEl = document.getElementById('ocrJobList');
      const jobCountEl = document.getElementById('jobCount');
      const jobDetailsEl = document.getElementById('ocrJobDetails');
      const statusLabelEl = document.getElementById('jobStatusLabel');
      const feedbackEl = document.getElementById('ocrFeedback');
      const formEl = document.getElementById('ocrForm');
      const fileInput = document.getElementById('images');
      const loadOlderBtn = document.getElementById('loadOlderJobs');
      const jobRangeNoteEl = document.getElementById('jobRangeNote');
      const deleteJobBtn = document.getElementById('deleteJobBtn');
      const refreshJobBtn = document.getElementById('refreshJobBtn');

      if (initialJobDetail && initialJobDetail.id) {
        state.jobDetails[initialJobDetail.id] = initialJobDetail;
      }
      if (!state.jobs.length && initialJobDetail && initialJobDetail.id) {
        state.jobs = [initialJobDetail];
      }

      const escapeHtml = (str = '') =>
        String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');

      const formatDate = (value) => {
        if (!value) return 'N/A';
        try {
          return new Date(value).toLocaleString();
        } catch {
          return value;
        }
      };

      const statusClass = (status) => {
        switch (status) {
          case 'completed':
            return 'status-completed';
          case 'processing':
            return 'status-processing';
          case 'failed':
            return 'status-failed';
          default:
            return 'status-queued';
        }
      };

      const MAX_COORD_VALUE = 1000;
      const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
      const percentOfCanvas = (value) => clamp((value / MAX_COORD_VALUE) * 100, 0, 100);
      const enrichBoxesForOverlay = (boxes = []) => boxes.map((box, index) => {
        const width = clamp(box.endX - box.startX, 1, MAX_COORD_VALUE);
        const height = clamp(box.endY - box.startY, 1, MAX_COORD_VALUE);
        return {
          ...box,
          id: box.id || `${index}-${box.startX}-${box.startY}`,
          leftPercent: percentOfCanvas(box.startX),
          topPercent: percentOfCanvas(box.startY),
          widthPercent: clamp((width / MAX_COORD_VALUE) * 100, 0.5, 100),
          heightPercent: clamp((height / MAX_COORD_VALUE) * 100, 0.5, 100),
        };
      });

      const parseSegmentsFromRawText = (rawText = '') => {
        if (typeof rawText !== 'string' || !rawText.trim()) return [];
        const pattern = /([\s\S]*?)\((\d{1,3}),(\d{1,3})\),\((\d{1,3}),(\d{1,3})\)/g;
        const results = [];
        let match;
        while ((match = pattern.exec(rawText)) !== null) {
          const text = (match[1] || '').trim();
          if (!text) continue;
          const coords = match.slice(2).map((v) => clamp(parseInt(v, 10) || 0, 0, MAX_COORD_VALUE));
          results.push({
            text,
            startX: coords[0],
            startY: coords[1],
            endX: coords[2],
            endY: coords[3],
          });
        }
        return enrichBoxesForOverlay(results);
      };

      const computeLayoutTextFromSegments = (segments = []) => {
        if (!Array.isArray(segments) || !segments.length) return '';
        const height = (box) => Math.max(1, box.endY - box.startY);
        const yOverlap = (a, b) => Math.max(0, Math.min(a.endY, b.endY) - Math.max(a.startY, b.startY));
        const sharesRow = (a, b) => {
          const overlap = yOverlap(a, b);
          return overlap >= 0.5 * height(a) && overlap >= 0.5 * height(b);
        };
        const normalized = segments
          .filter((box) => box && typeof box.text === 'string')
          .map((box) => ({
            ...box,
            text: box.text.trim(),
          }))
          .filter((box) => box.text);
        if (!normalized.length) return '';
        const sorted = normalized.sort((a, b) => (a.startY - b.startY) || (a.startX - b.startX));
        const rows = [];
        sorted.forEach((box) => {
          const targetRow = rows.find((row) => row.some((entry) => sharesRow(entry, box)));
          if (targetRow) {
            targetRow.push(box);
          } else {
            rows.push([box]);
          }
        });
        const lines = rows
          .map((row) => row
            .sort((a, b) => a.startX - b.startX)
            .map((box) => (box.text || '').trim())
            .filter(Boolean)
            .join('  '))
          .filter(Boolean);
        return lines.join('\n');
      };

      const hasActiveJobs = () => state.jobs.some((job) => job.status === 'processing' || job.status === 'queued');

      const setFeedback = (message, tone = 'info') => {
        if (!feedbackEl) return;
        if (!message) {
          feedbackEl.innerHTML = '';
          return;
        }
        feedbackEl.innerHTML = `<span class="is-${tone}">${escapeHtml(message)}</span>`;
      };

      const updateRangeNote = () => {
        if (!jobRangeNoteEl) return;
        jobRangeNoteEl.textContent = state.hasOlder
          ? 'Showing the last 7 days. Load older jobs to browse history.'
          : 'Showing available OCR jobs.';
      };

      const updateLoadOlderBtn = () => {
        if (!loadOlderBtn) return;
        if (!state.hasOlder) {
          loadOlderBtn.disabled = true;
          loadOlderBtn.textContent = 'No older jobs';
          return;
        }
        loadOlderBtn.disabled = state.loadingOlder;
        loadOlderBtn.textContent = state.loadingOlder ? 'Loading...' : 'Load older jobs';
      };

      const mergeJobSummaries = (jobs = []) => {
        if (!Array.isArray(jobs) || !jobs.length) return;
        const map = new Map(state.jobs.map((job) => [job.id, job]));
        jobs.forEach((job) => {
          if (job && job.id) {
            const existing = map.get(job.id) || {};
            map.set(job.id, { ...existing, ...job });
          }
        });
        state.jobs = Array.from(map.values())
          .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        state.oldestLoaded = state.jobs.length ? state.jobs[state.jobs.length - 1].createdAt : null;
        if (!state.selectedJobId && state.jobs.length) {
          state.selectedJobId = state.jobs[0].id;
        }
        renderJobs();
      };

      const summarizeCounts = (job) => {
        if (job.counts) return job.counts;
        const files = Array.isArray(job.files) ? job.files : [];
        const total = files.length;
        const completed = files.filter((f) => f.status === 'completed').length;
        const failed = files.filter((f) => f.status === 'failed').length;
        const processing = files.filter((f) => f.status === 'processing').length;
        return { total, completed, failed, processing };
      };

      const collectSegmentsFromDom = (fileId) => {
        const rows = Array.from(jobDetailsEl?.querySelectorAll(`[data-segment-row="${fileId}"]`) || []);
        return rows.map((row) => ({
          text: row.querySelector('[data-segment-text]')?.value || '',
          startX: Number(row.dataset.startx || 0),
          startY: Number(row.dataset.starty || 0),
          endX: Number(row.dataset.endx || 0),
          endY: Number(row.dataset.endy || 0),
        }));
      };

      const updateLayoutFromSegments = (jobId, fileId) => {
        const layoutField = jobDetailsEl?.querySelector(`[data-layout-input="${fileId}"]`);
        if (!layoutField) return;
        const segments = collectSegmentsFromDom(fileId);
        const layoutText = computeLayoutTextFromSegments(segments);
        layoutField.value = layoutText;
        const job = state.jobDetails[jobId];
        if (job) {
          const targetFile = job.files.find((f) => f.id === fileId);
          if (targetFile && targetFile.result) {
            targetFile.result.layoutText = layoutText;
          }
        }
      };

      const selectJob = (jobId) => {
        state.selectedJobId = jobId;
        state.didScrollToHighlight = false;
        renderJobs();
        renderJobDetails();
        ensureJobDetail(jobId);
      };

      const renderJobs = () => {
        if (!jobListEl) return;

        if (!state.jobs.length) {
          jobListEl.innerHTML = '<div class="job-empty-state">No jobs yet. Upload files to kick things off.</div>';
          if (jobCountEl) jobCountEl.textContent = '0 jobs';
          updateRangeNote();
          updateLoadOlderBtn();
          return;
        }

        const items = state.jobs.map((job) => {
          const counts = summarizeCounts(job);
          const isActive = job.id === state.selectedJobId;
          const ownerLabel = job.owner && job.owner.name ? escapeHtml(job.owner.name) : 'You';
          const createdAt = formatDate(job.createdAt);
          const failedLabel = counts.failed ? ` - ${counts.failed} failed` : '';
          return `
            <button type="button" class="job-row ${isActive ? 'is-active' : ''}" data-job-id="${job.id}">
              <div class="job-status-line">
                <span class="status-badge ${statusClass(job.status)}">${escapeHtml(job.status)}</span>
                <span>${counts.completed}/${counts.total} files${failedLabel}</span>
              </div>
              <div class="job-meta-line">
                <span>${escapeHtml(createdAt)}</span>
                <span>${ownerLabel}</span>
              </div>
            </button>
          `;
        }).join('');

        jobListEl.innerHTML = items;
        jobListEl.querySelectorAll('[data-job-id]').forEach((el) => {
          el.addEventListener('click', () => selectJob(el.dataset.jobId));
        });
        if (jobCountEl) {
          jobCountEl.textContent = `${state.jobs.length} ${state.jobs.length === 1 ? 'job' : 'jobs'}`;
        }
        updateRangeNote();
        updateLoadOlderBtn();
      };

      const renderFileCard = (job, file, order, options = {}) => {
        const isHighlighted = options.highlightFileId && options.highlightFileId === file.id;
        const rawId = `raw-${file.id}`;
        const layoutId = `layout-${file.id}`;
        const counts = summarizeCounts(job);
        const fileInfo = [
          `Order ${order}/${counts.total || job.files.length}`,
          `${(file.size / 1024).toFixed(1)} KB`,
          file.mimetype || 'unknown type',
        ].join(' | ');

        const overlayHtml = file.result && file.result.overlayBoxes && file.result.overlayBoxes.length
          ? file.result.overlayBoxes.map((box) => `
                <div class="bounding-box" style="left:${box.leftPercent}%;top:${box.topPercent}%;width:${box.widthPercent}%;height:${box.heightPercent}%;">
                  <span class="box-label">${escapeHtml(box.text)}</span>
                </div>
              `).join('')
          : '';

        const imageStage = file.result && file.result.imagePath
          ? `
            <div class="image-stage">
              <img src="${file.result.imagePath}" alt="${escapeHtml(file.originalname)} preview" loading="lazy" />
              <div class="box-layer">
                ${overlayHtml || ''}
              </div>
            </div>
          `
          : '<p class="text-muted mb-0">Awaiting OCR output...</p>';

        const rawTextSection = file.result?.rawText
          ? `
            <div class="text-card">
              <div class="text-card-header">
                <h5>Raw output</h5>
                <button class="copy-btn" type="button" data-copy-source="${rawId}">Copy</button>
              </div>
              <pre id="${rawId}">${escapeHtml(file.result.rawText)}</pre>
            </div>
          `
          : '';

        const segmentsSection = file.result?.overlayBoxes
          ? `
            <div class="segment-editor" data-segment-list="${file.id}">
              ${file.result.overlayBoxes.map((box) => `
                <div class="segment-row" data-segment-row="${file.id}" data-startx="${box.startX}" data-starty="${box.startY}" data-endx="${box.endX}" data-endy="${box.endY}">
                  <div class="segment-input">
                    <input type="text" value="${escapeHtml(box.text)}" data-segment-text />
                    <div class="segment-coords">(${box.startX}, ${box.startY}) -> (${box.endX}, ${box.endY})</div>
                  </div>
                  <button class="segment-remove" type="button" data-remove-segment="${box.id}" data-file-id="${file.id}">Remove</button>
                </div>
              `).join('')}
            </div>
          `
          : '<p class="text-muted mb-0">No OCR segments available.</p>';

        const layoutValue = file.result?.layoutText || '';
        const layoutSection = file.result
          ? `
            <div class="text-card">
              <div class="text-card-header">
                <h5>Layout text</h5>
                <button class="copy-btn" type="button" data-copy-source="${layoutId}">Copy</button>
              </div>
              <textarea id="${layoutId}" class="layout-textarea" data-layout-input="${file.id}" data-job-id="${job.id}" placeholder="Edit OCR layout text and save.">${escapeHtml(layoutValue)}</textarea>
              <p class="ocr-note">Edits are saved to the database and won't change the original job date.</p>
              <div class="edit-actions">
                <button class="save-edits-btn" type="button" data-save-file="${file.id}" data-job-id="${job.id}">Save OCR edits</button>
                <button class="restore-edits-btn" type="button" data-restore-file="${file.id}" data-job-id="${job.id}">Restore from raw output</button>
              </div>
              <div class="text-card-header mt-3">
                <h5>Segments</h5>
              </div>
              ${segmentsSection}
            </div>
          `
          : '';

        const fileError = file.error
          ? `<div class="file-error">${escapeHtml(file.error)}</div>`
          : '';

        return `
          <section class="file-card ${isHighlighted ? 'is-highlighted' : ''}" data-file-card="${file.id}">
            <h4>
              <span>${escapeHtml(file.originalname || 'Image')}</span>
              <span class="status-badge ${statusClass(file.status)}">${escapeHtml(file.status)}</span>
            </h4>
            <div class="file-meta">${escapeHtml(fileInfo)}</div>
            ${imageStage}
            ${rawTextSection}
            ${layoutSection}
            ${fileError}
          </section>
        `;
      };

      const renderJobDetails = () => {
        if (!jobDetailsEl) return;
        if (state.isEditingLayout) return;

        const summary = state.jobs.find((j) => j.id === state.selectedJobId);
        const job = state.jobDetails[state.selectedJobId];
        const isLoading = state.detailLoading[state.selectedJobId];

        if (!state.selectedJobId) {
          const emptyMessage = state.singleJobMode
            ? 'Loading job details...'
            : 'Select a job from the queue to inspect its files and results.';
          jobDetailsEl.innerHTML = `<p class="text-muted mb-0">${escapeHtml(emptyMessage)}</p>`;
          if (statusLabelEl) statusLabelEl.textContent = '';
          return;
        }

        if (!job) {
          jobDetailsEl.innerHTML = isLoading
            ? '<p class="text-muted mb-0">Loading job...</p>'
            : '<p class="text-muted mb-0">Loading job details...</p>';
          if (!isLoading) {
            ensureJobDetail(state.selectedJobId);
          }
          if (statusLabelEl && summary) {
            const counts = summarizeCounts(summary);
            statusLabelEl.textContent = `${summary.status.toUpperCase()} - ${counts.total} files`;
          }
          return;
        }

        const counts = summarizeCounts(job);
        if (statusLabelEl) {
          statusLabelEl.textContent = `${job.status.toUpperCase()} - ${counts.total} files`;
        }

        const hasSendable = job.files.some((file) => file.status === 'completed' && file.result && file.result.imagePath);
        const forwardHtml = `
          <div class="job-actions">
            <button type="button" class="forward-btn" data-send-job="${job.id}" ${hasSendable ? '' : 'disabled'}>
              Send receipts to inbox
            </button>
            <p class="ocr-note">Layout text edits are forwarded with the receipts.</p>
          </div>
        `;
        const metaHtml = `
          <div class="job-meta-grid">
            <div class="meta-block">
              <div class="meta-label">Status</div>
              <div class="meta-value"><span class="status-badge ${statusClass(job.status)}">${escapeHtml(job.status)}</span></div>
            </div>
            <div class="meta-block">
              <div class="meta-label">Files</div>
              <div class="meta-value">${counts.completed}/${counts.total} done${counts.failed ? ` - ${counts.failed} failed` : ''}</div>
            </div>
            <div class="meta-block">
              <div class="meta-label">Created</div>
              <div class="meta-value">${escapeHtml(formatDate(job.createdAt))}</div>
            </div>
            <div class="meta-block">
              <div class="meta-label">Updated</div>
              <div class="meta-value">${escapeHtml(formatDate(job.updatedAt))}</div>
            </div>
          </div>
        `;

        const promptHtml = `
          <div class="job-prompt-block">
            <div class="text-card-header">
              <h3>Prompt</h3>
              <button class="copy-btn" type="button" data-copy-source="prompt-block">Copy</button>
            </div>
            <pre id="prompt-block">${escapeHtml(job.prompt)}</pre>
          </div>
        `;

        const jobErrorHtml = job.error
          ? `<div class="job-error">${escapeHtml(job.error)}</div>`
          : '';

        const filesHtml = job.files.map((file, index) => renderFileCard(job, file, index + 1, {
          highlightFileId: state.highlightFileId,
        })).join('');

        jobDetailsEl.innerHTML = metaHtml + forwardHtml + promptHtml + jobErrorHtml + filesHtml;
        if (state.highlightFileId) {
          const targetCard = jobDetailsEl.querySelector(`[data-file-card="${state.highlightFileId}"]`);
          if (targetCard) {
            targetCard.classList.add('is-highlighted');
            if (!state.didScrollToHighlight) {
              targetCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
              state.didScrollToHighlight = true;
            }
          }
        }
      };

      const ensureJobDetail = async (jobId, options = {}) => {
        if (!jobId) return;
        if (state.detailLoading[jobId]) return;
        if (!options.refresh && state.jobDetails[jobId]) return;

        state.detailLoading[jobId] = true;
        renderJobDetails();

        try {
          const response = await fetch(`${JOBS_ENDPOINT}/${jobId}`, { headers: { Accept: 'application/json' } });
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to load job.');
          }
          state.jobDetails[jobId] = payload.job;
          mergeJobSummaries([payload.job]);
          renderJobDetails();
        } catch (error) {
          setFeedback(error.message || 'Failed to load job.', 'error');
        } finally {
          delete state.detailLoading[jobId];
        }
      };

      const dataUrlFromPath = async (imagePath) => {
        const response = await fetch(imagePath, { cache: 'no-store' });
        if (!response.ok) throw new Error('Unable to load OCR preview image.');
        return response.blob();
      };

      const forwardJobToReceipts = async (jobId) => {
        if (state.isForwarding) {
          return;
        }
        const job = state.jobDetails[jobId];
        if (!job) {
          setFeedback('Select a job to send to receipts.', 'error');
          return;
        }
        const sendableFiles = job.files.filter((file) => file.status === 'completed' && file.result && file.result.imagePath);
        if (!sendableFiles.length) {
          setFeedback('No completed OCR results to send.', 'error');
          return;
        }

        const formData = new FormData();
        let appended = 0;
        for (const file of sendableFiles) {
          try {
            const blob = await dataUrlFromPath(file.result.imagePath);
            const filename = file.originalname || `ocr-receipt-${appended + 1}.jpg`;
            formData.append('imgs', blob, filename);
            formData.append('layout_texts', file.result.layoutText || '');
            appended += 1;
          } catch (error) {
            setFeedback(error.message || 'Failed to prepare images.', 'error');
            return;
          }
        }

        if (!appended) {
          setFeedback('Images are missing or invalid; nothing was sent.', 'error');
          return;
        }

        state.isForwarding = true;
        setFeedback(`Sending ${appended} ${appended === 1 ? 'receipt' : 'receipts'} to inbox...`, 'info');

        try {
          const response = await fetch(RECEIPT_ENDPOINT, {
            method: 'POST',
            body: formData,
            headers: { Accept: 'application/json' },
          });
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to send receipts.');
          }
          setFeedback(`Sent ${appended} ${appended === 1 ? 'receipt' : 'receipts'} to the inbox.`, 'success');
        } catch (error) {
          setFeedback(error.message || 'Failed to send receipts.', 'error');
        } finally {
          state.isForwarding = false;
        }
      };

      const handleFormSubmit = async (event) => {
        event.preventDefault();
        if (state.isSubmitting) return;
        if (!formEl) return;

        const formData = new FormData(formEl);
        state.isSubmitting = true;
        setFeedback('Queuing OCR job...', 'info');

        try {
          const response = await fetch(formEl.action, {
            method: 'POST',
            body: formData,
            headers: { Accept: 'application/json' },
          });
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to queue OCR job.');
          }
          if (payload.job) {
            mergeJobSummaries([payload.job]);
            state.jobDetails[payload.job.id] = payload.job;
            state.selectedJobId = payload.job.id;
            renderJobDetails();
          }
          setFeedback('Job queued successfully.', 'success');
          if (fileInput) fileInput.value = '';
        } catch (error) {
          setFeedback(error.message || 'Failed to queue OCR job.', 'error');
        } finally {
          state.isSubmitting = false;
          fetchJobs(true);
        }
      };

      const buildJobsUrl = () => {
        const params = new URLSearchParams({ scope: 'recent' });
        if (state.latestUpdatedAt) {
          params.set('updated_since', state.latestUpdatedAt);
        }
        return `${JOBS_ENDPOINT}?${params.toString()}`;
      };

      const stopPolling = () => {
        if (state.pollTimer) {
          clearTimeout(state.pollTimer);
          state.pollTimer = null;
        }
      };

      const scheduleNextPoll = (preferFast = false) => {
        stopPolling();
        const interval = preferFast || hasActiveJobs() ? FAST_POLL_MS : SLOW_POLL_MS;
        state.pollTimer = setTimeout(fetchJobs, interval);
      };

      const fetchJobs = async (preferFast = false) => {
        if (state.isEditingLayout) {
          stopPolling();
          return;
        }
        if (state.isFetchingJobs) {
          return;
        }

        state.isFetchingJobs = true;
        let hadUpdates = false;

        try {
          if (state.singleJobMode && state.selectedJobId) {
            await ensureJobDetail(state.selectedJobId, { refresh: true });
            hadUpdates = hasActiveJobs();
          } else {
            const response = await fetch(buildJobsUrl(), { headers: { Accept: 'application/json' } });
            if (!response.ok) return;
            const payload = await response.json();
            const payloadJobs = Array.isArray(payload.jobs) ? payload.jobs : [];
            hadUpdates = payloadJobs.length > 0;
            if (payload.latestUpdatedAt) {
              state.latestUpdatedAt = payload.latestUpdatedAt;
            }
            if (typeof payload.hasOlder === 'boolean') {
              state.hasOlder = payload.hasOlder;
            }
            mergeJobSummaries(payloadJobs);
            const selectedSummary = state.jobs.find((job) => job.id === state.selectedJobId);
            if (selectedSummary && selectedSummary.status !== 'completed') {
              ensureJobDetail(selectedSummary.id, { refresh: true });
            }
          }
        } catch {
          // Silent failure, polling will retry
        } finally {
          state.isFetchingJobs = false;
          scheduleNextPoll(hadUpdates || preferFast);
        }
      };

      const startPolling = (preferFast = false) => {
        if (state.isEditingLayout) return;
        scheduleNextPoll(preferFast);
      };

      const loadOlderJobs = async () => {
        if (state.singleJobMode) {
          return;
        }
        if (state.loadingOlder || !state.hasOlder) {
          return;
        }
        state.loadingOlder = true;
        updateLoadOlderBtn();
        setFeedback('Loading older jobs...', 'info');

        try {
          const before = state.oldestLoaded || new Date().toISOString();
          const params = new URLSearchParams({ scope: 'all', before, limit: 30 });
          const response = await fetch(`${JOBS_ENDPOINT}?${params.toString()}`, { headers: { Accept: 'application/json' } });
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to load older jobs.');
          }
          if (Array.isArray(payload.jobs)) {
            mergeJobSummaries(payload.jobs);
          }
          if (typeof payload.hasOlder === 'boolean') {
            state.hasOlder = payload.hasOlder;
          }
          setFeedback('', 'info');
        } catch (error) {
          setFeedback(error.message || 'Failed to load older jobs.', 'error');
        } finally {
          state.loadingOlder = false;
          updateLoadOlderBtn();
        }
      };

      const saveOcrEdits = async (jobId, fileId, options = {}) => {
        if (!jobId || !fileId || state.savingEdits[fileId]) return;
        const layoutField = jobDetailsEl?.querySelector(`[data-layout-input="${fileId}"]`);
        const segments = Array.isArray(options.segmentsOverride)
          ? options.segmentsOverride
          : collectSegmentsFromDom(fileId);
        const layoutText = typeof options.layoutOverride === 'string'
          ? options.layoutOverride
          : computeLayoutTextFromSegments(segments);
        if (layoutField) {
          layoutField.value = layoutText;
        }
        state.savingEdits[fileId] = true;
        setFeedback('Saving OCR edits...', 'info');

        try {
          const response = await fetch(`${JOBS_ENDPOINT}/${jobId}/files/${fileId}`, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              Accept: 'application/json',
            },
            body: JSON.stringify({
              layoutText,
              overlayBoxes: segments,
            }),
          });
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to save OCR edits.');
          }
          state.jobDetails[jobId] = payload.job;
          mergeJobSummaries([payload.job]);
          renderJobDetails();
          setFeedback('Edits saved.', 'success');
        } catch (error) {
          setFeedback(error.message || 'Failed to save OCR edits.', 'error');
        } finally {
          delete state.savingEdits[fileId];
        }
      };

      const deleteSelectedJob = async () => {
        if (!state.selectedJobId || state.deletingJob) return;
        const confirmed = window.confirm('Delete this OCR job and its preview image?');
        if (!confirmed) return;

        state.deletingJob = true;
        if (deleteJobBtn) deleteJobBtn.disabled = true;
        setFeedback('Deleting job...', 'info');

        try {
          const response = await fetch(`${JOBS_ENDPOINT}/${state.selectedJobId}`, { method: 'DELETE', headers: { Accept: 'application/json' } });
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to delete job.');
          }
          state.jobs = state.jobs.filter((job) => job.id !== state.selectedJobId);
          delete state.jobDetails[state.selectedJobId];
          state.selectedJobId = state.jobs.length ? state.jobs[0].id : null;
          renderJobs();
          renderJobDetails();
          setFeedback('Job deleted.', 'success');
        } catch (error) {
          setFeedback(error.message || 'Failed to delete job.', 'error');
        } finally {
          state.deletingJob = false;
          if (deleteJobBtn) deleteJobBtn.disabled = false;
        }
      };

      document.addEventListener('click', (event) => {
        const target = event.target.closest('[data-copy-source]');
        if (!target) return;
        const pre = document.getElementById(target.dataset.copySource);
        if (!pre) return;
        const text = typeof pre.value === 'string' ? pre.value : (pre.textContent || '');
        navigator.clipboard.writeText(text).then(() => {
          target.textContent = 'Copied';
          setTimeout(() => {
            target.textContent = 'Copy';
          }, 1500);
        });
      });

      document.addEventListener('click', (event) => {
        const sendButton = event.target.closest('[data-send-job]');
        if (sendButton && !sendButton.disabled) {
          sendButton.disabled = true;
          forwardJobToReceipts(sendButton.dataset.sendJob).finally(() => {
            sendButton.disabled = false;
          });
        }
      });

      document.addEventListener('click', (event) => {
        const saveBtn = event.target.closest('[data-save-file]');
        if (saveBtn) {
          saveOcrEdits(saveBtn.dataset.jobId, saveBtn.dataset.saveFile);
        }
      });

      document.addEventListener('click', (event) => {
        const removeBtn = event.target.closest('[data-remove-segment]');
        if (!removeBtn) return;
        const row = removeBtn.closest('[data-segment-row]');
        if (row && row.parentElement) {
          row.parentElement.removeChild(row);
        }
        if (state.selectedJobId && removeBtn.dataset.fileId) {
          updateLayoutFromSegments(state.selectedJobId, removeBtn.dataset.fileId);
        }
      });

      document.addEventListener('click', (event) => {
        const refreshBtnClick = event.target.closest('#refreshJobBtn');
        if (refreshBtnClick && state.selectedJobId) {
          ensureJobDetail(state.selectedJobId, { refresh: true });
        }
      });

      document.addEventListener('click', (event) => {
        const restoreBtn = event.target.closest('[data-restore-file]');
        if (!restoreBtn) return;
        const jobId = restoreBtn.dataset.jobId;
        const fileId = restoreBtn.dataset.restoreFile;
        const job = state.jobDetails[jobId];
        const file = job?.files.find((f) => f.id === fileId);
        if (!job || !file || !file.result) return;
        const parsedBoxes = parseSegmentsFromRawText(file.result.rawText || '');
        const targetBoxes = parsedBoxes.length
          ? parsedBoxes
          : (Array.isArray(file.result.originalOverlayBoxes) ? file.result.originalOverlayBoxes : []);
        const targetLayout = parsedBoxes.length
          ? computeLayoutTextFromSegments(parsedBoxes)
          : (file.result.originalLayoutText || file.result.layoutText || '');
        file.result.overlayBoxes = targetBoxes;
        file.result.layoutText = targetLayout;
        renderJobDetails();
        saveOcrEdits(jobId, fileId, { segmentsOverride: targetBoxes, layoutOverride: targetLayout });
      });

      document.addEventListener('input', (event) => {
        const segmentInput = event.target.closest('[data-segment-text]');
        if (segmentInput && state.selectedJobId) {
          const row = segmentInput.closest('[data-segment-row]');
          if (row) {
            updateLayoutFromSegments(state.selectedJobId, row.dataset.segmentRow);
          }
        }
      });

      if (jobDetailsEl) {
        jobDetailsEl.addEventListener('focusin', (event) => {
          if (event.target.closest('[data-layout-input]') || event.target.closest('[data-segment-text]')) {
            state.isEditingLayout = true;
            stopPolling();
          }
        });
        jobDetailsEl.addEventListener('focusout', (event) => {
          if (event.target.closest('[data-layout-input]') || event.target.closest('[data-segment-text]')) {
            state.isEditingLayout = false;
            startPolling(true);
          }
        });
      }

      if (formEl) {
        formEl.addEventListener('submit', handleFormSubmit);
      }

      if (loadOlderBtn) {
        loadOlderBtn.addEventListener('click', loadOlderJobs);
      }

      if (deleteJobBtn) {
        deleteJobBtn.addEventListener('click', deleteSelectedJob);
      }

      state.oldestLoaded = state.jobs.length ? state.jobs[state.jobs.length - 1].createdAt : null;
      if (state.jobs.length && !state.selectedJobId) {
        state.selectedJobId = state.jobs[0].id;
      }
      renderJobs();
      renderJobDetails();
      if (state.selectedJobId) {
        const refreshNow = state.singleJobMode || !state.jobDetails[state.selectedJobId];
        ensureJobDetail(state.selectedJobId, { refresh: refreshNow });
      }
      startPolling(true);
    })();
