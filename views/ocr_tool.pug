extends layout

block styles
  style.
    :root {
      --ocr-bg: #0E0F13;
      --ocr-surface-1: #171A20;
      --ocr-surface-2: #1B2026;
      --ocr-surface-3: #20242A;
      --ocr-border: #262B34;
      --ocr-divider: #2B313C;
      --ocr-text: #E8ECF2;
      --ocr-text-secondary: #C1C7D3;
      --ocr-text-muted: #9AA3B2;
      --ocr-brand: #FF6A1F;
      --ocr-brand-hover: #FF7C3B;
      --ocr-brand-active: #E05F1C;
      --ocr-accent: #FFC247;
      --ocr-accent-hover: #FFD36F;
      --ocr-success: #17C696;
      --ocr-warning: #FFC63D;
      --ocr-danger: #FF4D4F;
      --ocr-focus: #FFC247;
    }

    .ocr-page {
      background: var(--ocr-bg);
      color: var(--ocr-text);
      border-radius: 24px;
      padding: 2rem;
      margin: 1rem 0 3rem;
      box-shadow: 0 50px 120px rgba(0, 0, 0, 0.35);
    }

    .ocr-header h1 {
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .ocr-header p {
      color: var(--ocr-text-secondary);
      max-width: 900px;
      margin-bottom: 1.5rem;
    }

    .ocr-status {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.6rem 0.9rem;
      border-radius: 999px;
      background: var(--ocr-surface-2);
      border: 1px solid var(--ocr-border);
      color: var(--ocr-text-secondary);
      margin-bottom: 1rem;
    }

    .ocr-status .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .ocr-status.is-ok .dot {
      background: var(--ocr-success);
    }

    .ocr-status.is-warn .dot {
      background: var(--ocr-warning);
    }

    .ocr-grid {
      display: grid;
      grid-template-columns: minmax(0, 360px) minmax(0, 1fr);
      gap: 1.5rem;
    }

    @media (max-width: 1200px) {
      .ocr-grid {
        grid-template-columns: 1fr;
      }
    }

    .ocr-card {
      background: var(--ocr-surface-1);
      border: 1px solid var(--ocr-border);
      border-radius: 18px;
      padding: 1.5rem;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.01);
    }

    .ocr-card + .ocr-card {
      margin-top: 1.25rem;
    }

    .ocr-card h2,
    .ocr-card h3 {
      margin-bottom: 0.75rem;
      font-weight: 600;
    }

    .ocr-form label {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--ocr-text-muted);
      margin-bottom: 0.4rem;
    }

    .ocr-form input,
    .ocr-form textarea {
      width: 100%;
      background: var(--ocr-surface-2);
      border: 1px solid var(--ocr-border);
      color: var(--ocr-text);
      border-radius: 10px;
      padding: 0.75rem;
      font-size: 0.95rem;
    }

    .ocr-form textarea {
      min-height: 120px;
      resize: vertical;
    }

    .ocr-form input:focus,
    .ocr-form textarea:focus {
      outline: 2px solid var(--ocr-focus);
      border-color: var(--ocr-focus);
    }

    .ocr-form button {
      margin-top: 1rem;
      width: 100%;
      border: none;
      border-radius: 999px;
      padding: 0.85rem;
      background: var(--ocr-brand);
      color: #111418;
      font-weight: 600;
      transition: background 0.2s ease;
    }

    .ocr-form button:hover {
      background: var(--ocr-brand-hover);
    }

    .ocr-form button:active {
      background: var(--ocr-brand-active);
    }

    .job-list-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
    }

    .job-list-header span {
      color: var(--ocr-text-muted);
      font-size: 0.85rem;
    }

    .job-rows {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .job-row {
      border: 1px solid var(--ocr-border);
      border-radius: 12px;
      padding: 0.85rem;
      background: var(--ocr-surface-2);
      color: inherit;
      width: 100%;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      transition: border-color 0.2s ease, transform 0.2s ease;
    }

    .job-row:hover {
      border-color: var(--ocr-accent);
      transform: translateX(2px);
    }

    .job-row.is-active {
      border-color: var(--ocr-brand);
      box-shadow: 0 0 0 1px var(--ocr-brand);
    }

    .job-row .job-status-line {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .status-badge {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      border: 1px solid transparent;
    }

    .status-queued {
      border-color: var(--ocr-border);
      color: var(--ocr-text-muted);
    }

    .status-processing {
      border-color: var(--ocr-warning);
      color: var(--ocr-warning);
    }

    .status-completed {
      border-color: var(--ocr-success);
      color: var(--ocr-success);
    }

    .status-failed {
      border-color: var(--ocr-danger);
      color: var(--ocr-danger);
    }

    .job-row .job-meta-line {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--ocr-text-muted);
    }

    .job-empty-state {
      background: var(--ocr-surface-2);
      border-radius: 12px;
      padding: 1rem;
      border: 1px dashed var(--ocr-border);
      color: var(--ocr-text-muted);
      text-align: center;
    }

    .job-details-header {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    .job-meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .meta-block {
      background: var(--ocr-surface-2);
      border: 1px solid var(--ocr-border);
      border-radius: 12px;
      padding: 0.75rem;
    }

    .meta-label {
      font-size: 0.75rem;
      color: var(--ocr-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .meta-value {
      font-weight: 600;
      margin-top: 0.3rem;
      word-break: break-word;
    }

    .job-prompt-block {
      background: var(--ocr-surface-2);
      border: 1px solid var(--ocr-border);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }

    .job-prompt-block pre {
      margin: 0;
      color: var(--ocr-text);
      white-space: pre-wrap;
    }

    .job-error {
      margin-top: 0.5rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(255, 77, 79, 0.09);
      border: 1px solid rgba(255, 77, 79, 0.4);
      color: var(--ocr-danger);
    }

    .file-card {
      border: 1px solid var(--ocr-border);
      border-radius: 16px;
      padding: 1.25rem;
      background: var(--ocr-surface-2);
      margin-bottom: 1.25rem;
    }

    .file-card h4 {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .file-meta {
      color: var(--ocr-text-muted);
      font-size: 0.85rem;
      margin-bottom: 1rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .file-error {
      margin-top: 0.75rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: rgba(255, 77, 79, 0.09);
      border: 1px dashed rgba(255, 77, 79, 0.5);
      color: var(--ocr-danger);
    }

    .image-stage {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #020305;
      border: 1px solid var(--ocr-border);
    }

    .image-stage img {
      display: block;
      width: 100%;
      height: auto;
    }

    .box-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .bounding-box {
      position: absolute;
      border: 2px solid rgba(255, 106, 31, 0.9);
      background: rgba(255, 106, 31, 0.16);
      border-radius: 8px;
      pointer-events: auto;
      transition: border-color 0.2s ease;
    }

    .bounding-box:hover {
      border-color: var(--ocr-accent);
      background: rgba(255, 194, 71, 0.18);
      z-index: 5;
    }

    .bounding-box .box-label {
      position: absolute;
      top: 100%;
      left: 0;
      transform: translateY(6px);
      background: rgba(32, 36, 42, 0.95);
      color: var(--ocr-text);
      padding: 0.35rem 0.5rem;
      border-radius: 6px;
      font-size: 0.75rem;
      max-width: 260px;
      opacity: 0;
      pointer-events: none;
      white-space: pre-wrap;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .bounding-box:hover .box-label {
      opacity: 1;
      transform: translateY(0);
    }

    .text-card {
      background: var(--ocr-surface-3);
      border-radius: 14px;
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--ocr-border);
    }

    .text-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .copy-btn {
      background: transparent;
      border: 1px solid var(--ocr-accent);
      color: var(--ocr-accent);
      border-radius: 999px;
      font-size: 0.85rem;
      padding: 0.25rem 0.75rem;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .copy-btn:hover {
      background: rgba(255, 194, 71, 0.15);
      color: var(--ocr-text);
    }

    .text-card pre {
      margin: 0;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 0.85rem;
      color: var(--ocr-text-secondary);
      max-height: 320px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .layout-textarea {
      width: 100%;
      min-height: 180px;
      background: var(--ocr-surface-1);
      border: 1px solid var(--ocr-border);
      border-radius: 10px;
      color: var(--ocr-text);
      padding: 0.75rem;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      resize: vertical;
    }

    .layout-textarea:focus {
      outline: 2px solid var(--ocr-focus);
      border-color: var(--ocr-focus);
    }

    .job-actions {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      margin-bottom: 1.25rem;
    }

    .forward-btn {
      border: none;
      border-radius: 999px;
      padding: 0.85rem 1rem;
      background: var(--ocr-accent);
      color: #111418;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      transition: background 0.2s ease, transform 0.1s ease;
    }

    .forward-btn:hover:enabled {
      background: var(--ocr-accent-hover);
      transform: translateY(-1px);
    }

    .forward-btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      background: var(--ocr-border);
      color: var(--ocr-text-muted);
    }

    #ocrFeedback {
      margin-top: 1rem;
      min-height: 1.5rem;
      font-size: 0.9rem;
    }

    #ocrFeedback span {
      padding: 0.5rem 0.75rem;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    #ocrFeedback .is-success {
      background: rgba(23, 198, 150, 0.18);
      color: var(--ocr-success);
    }

    #ocrFeedback .is-error {
      background: rgba(255, 77, 79, 0.18);
      color: var(--ocr-danger);
    }

    #ocrFeedback .is-info {
      background: rgba(255, 194, 71, 0.18);
      color: var(--ocr-accent);
    }

    .ocr-note {
      font-size: 0.85rem;
      color: var(--ocr-text-muted);
      margin-top: 0.5rem;
    }

block content
  .ocr-page
    .ocr-header
      h1 OCR workspace
      p Harness the on-prem OCR stack with queued jobs, multi-image batches, and bounding-box visualization. Upload images, let the queue work in the background, and explore every job once it completes.
    if health
      .ocr-status(class=health.status === 'ok' ? 'is-ok' : 'is-warn')
        span.dot
        span Service #{health.status} · Model #{health.model || 'n/a'}
    else
      .ocr-status.is-warn
        span.dot
        span Unable to reach OCR health endpoint. Results might be unavailable.
    .ocr-grid
      .ocr-left
        .ocr-card
          h2 Submit images
          p.ocr-note The request will be queued; each file is processed sequentially with the same prompt and token limit.
          form#ocrForm.ocr-form(method='post', action='/ocr/jobs', enctype='multipart/form-data')
            label(for='images') Image files
            input#images(type='file', name='images', accept='image/*', multiple, required)
            label(for='max_new_tokens') Max new tokens
            input#max_new_tokens(type='number', name='max_new_tokens', min='1', max=tokenLimit, value=formValues.maxNewTokens, required)
            label(for='prompt') Prompt
            textarea#prompt(name='prompt')= formValues.prompt
            button(type='submit') Queue OCR job
          p.ocr-note Upload limit: #{process.env.OCR_JOB_MAX_FILES || 5} files · 25MB each
        .ocr-card
          .job-list-header
            h2 Job queue
            span#jobCount
          #ocrJobList.job-rows
            if jobs && jobs.length
              each job in jobs
                button.job-row(type='button', data-job-id=job.id)
                  .job-status-line
                    span.status-badge(class=`status-${job.status}`)= job.status
                    span= `${job.files.filter(f => f.status === 'completed').length}/${job.files.length} files`
                  .job-meta-line
                    span= new Date(job.createdAt).toLocaleTimeString()
                    span= job.owner && job.owner.name ? job.owner.name : 'You'
            else
              .job-empty-state
                span No jobs yet. Upload files to kick things off.
      .ocr-right
        .ocr-card
          .job-details-header
            h2 Job details
            span.text-muted#jobStatusLabel
          #ocrJobDetails
            p.text-muted Select a job from the queue to view its status and results.
    #ocrFeedback(aria-live='polite')
    noscript
      .alert.alert-warning.mb-0 This tool requires JavaScript to manage jobs and fetch results. Please enable JavaScript in your browser.

block script
  script.
    window.__INITIAL_JOBS__ = !{JSON.stringify(jobs || [])};
  script.
    (() => {
      const JOBS_ENDPOINT = '/ocr/jobs';
      const RECEIPT_ENDPOINT = '/receipt/upload_receipt';
      const POLL_INTERVAL = 5000;
      const state = {
        jobs: Array.isArray(window.__INITIAL_JOBS__) ? window.__INITIAL_JOBS__ : [],
        selectedJobId: null,
        isSubmitting: false,
        pollTimer: null,
        isForwarding: false,
        layoutEdits: {},
        isEditingLayout: false,
      };

      const jobListEl = document.getElementById('ocrJobList');
      const jobCountEl = document.getElementById('jobCount');
      const jobDetailsEl = document.getElementById('ocrJobDetails');
      const statusLabelEl = document.getElementById('jobStatusLabel');
      const feedbackEl = document.getElementById('ocrFeedback');
      const formEl = document.getElementById('ocrForm');
      const fileInput = document.getElementById('images');

      const escapeHtml = (str = '') =>
        String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');

      const formatDate = (value) => {
        if (!value) return 'N/A';
        try {
          return new Date(value).toLocaleString();
        } catch {
          return value;
        }
      };

      const dataUrlToBlob = (dataUrl) => {
        try {
          const [meta, base64] = dataUrl.split(',');
          const mimeMatch = meta.match(/data:(.*?);/);
          const mimeType = mimeMatch && mimeMatch[1] ? mimeMatch[1] : 'application/octet-stream';
          const binary = atob(base64);
          const buffer = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            buffer[i] = binary.charCodeAt(i);
          }
          return new Blob([buffer], { type: mimeType });
        } catch (error) {
          console.error('Failed to convert data URL', error);
          return null;
        }
      };

      const applyLayoutOverrides = (jobs) => jobs.map((job) => ({
        ...job,
        files: job.files.map((file) => {
          const override = state.layoutEdits[file.id];
          if (override !== undefined && file.result) {
            return { ...file, result: { ...file.result, layoutText: override } };
          }
          return file;
        }),
      }));

      const upsertLayoutEdit = (jobId, fileId, value) => {
        state.layoutEdits[fileId] = value;
        state.jobs = state.jobs.map((job) => {
          if (job.id !== jobId) return job;
          return {
            ...job,
            files: job.files.map((file) => {
              if (file.id !== fileId || !file.result) {
                return file;
              }
              return { ...file, result: { ...file.result, layoutText: value } };
            }),
          };
        });
      };

      const summarizeJob = (job) => {
        const total = job.files.length;
        const completed = job.files.filter((f) => f.status === 'completed').length;
        const failed = job.files.filter((f) => f.status === 'failed').length;
        const processing = job.files.filter((f) => f.status === 'processing').length;
        return { total, completed, failed, processing };
      };

      const statusClass = (status) => {
        switch (status) {
          case 'completed':
            return 'status-completed';
          case 'processing':
            return 'status-processing';
          case 'failed':
            return 'status-failed';
          default:
            return 'status-queued';
        }
      };

      const setJobs = (jobs, focusId) => {
        if (!Array.isArray(jobs)) {
          return;
        }
        state.jobs = applyLayoutOverrides(jobs);
        if (focusId) {
          state.selectedJobId = focusId;
        } else if (!state.jobs.find((job) => job.id === state.selectedJobId)) {
          state.selectedJobId = state.jobs.length ? state.jobs[0].id : null;
        }
        renderJobs();
        if (!state.isEditingLayout) {
          renderJobDetails();
        }
      };

      const selectJob = (jobId) => {
        state.selectedJobId = jobId;
        renderJobs();
        renderJobDetails();
      };

      const renderJobs = () => {
        if (!jobListEl) return;

        if (!state.jobs.length) {
          jobListEl.innerHTML = '<div class="job-empty-state">No jobs yet. Upload files to kick things off.</div>';
          if (jobCountEl) jobCountEl.textContent = '0 jobs';
          return;
        }

        const items = state.jobs.map((job) => {
          const summary = summarizeJob(job);
          const isActive = job.id === state.selectedJobId;
          const ownerLabel = job.owner && job.owner.name ? escapeHtml(job.owner.name) : 'You';
          const createdAt = formatDate(job.createdAt);
          return `
            <button type="button" class="job-row ${isActive ? 'is-active' : ''}" data-job-id="${job.id}">
              <div class="job-status-line">
                <span class="status-badge ${statusClass(job.status)}">${escapeHtml(job.status)}</span>
                <span>${summary.completed}/${summary.total} files${summary.failed ? ` · ${summary.failed} failed` : ''}</span>
              </div>
              <div class="job-meta-line">
                <span>${escapeHtml(createdAt)}</span>
                <span>${ownerLabel}</span>
              </div>
            </button>
          `;
        }).join('');

        jobListEl.innerHTML = items;
        jobListEl.querySelectorAll('[data-job-id]').forEach((el) => {
          el.addEventListener('click', () => selectJob(el.dataset.jobId));
        });
        if (jobCountEl) {
          jobCountEl.textContent = `${state.jobs.length} ${state.jobs.length === 1 ? 'job' : 'jobs'}`;
        }
      };

      const renderJobDetails = () => {
        if (!jobDetailsEl) return;

        const job = state.jobs.find((j) => j.id === state.selectedJobId);
        if (!job) {
          jobDetailsEl.innerHTML = '<p class="text-muted mb-0">Select a job from the queue to inspect its files and results.</p>';
          if (statusLabelEl) statusLabelEl.textContent = '';
          return;
        }

        if (statusLabelEl) {
          statusLabelEl.textContent = `${job.status.toUpperCase()} · ${job.files.length} files`;
        }

        const summary = summarizeJob(job);
        const hasSendable = job.files.some((file) => file.status === 'completed' && file.result && file.result.imageDataUrl);
        const forwardHtml = `
          <div class="job-actions">
            <button type="button" class="forward-btn" data-send-job="${job.id}" ${hasSendable ? '' : 'disabled'}>
              Send receipts to inbox
            </button>
            <p class="ocr-note">Layout text edits are forwarded with the receipts.</p>
          </div>
        `;
        const metaHtml = `
          <div class="job-meta-grid">
            <div class="meta-block">
              <div class="meta-label">Status</div>
              <div class="meta-value"><span class="status-badge ${statusClass(job.status)}">${escapeHtml(job.status)}</span></div>
            </div>
            <div class="meta-block">
              <div class="meta-label">Files</div>
              <div class="meta-value">${summary.completed}/${summary.total} done${summary.failed ? ` · ${summary.failed} failed` : ''}</div>
            </div>
            <div class="meta-block">
              <div class="meta-label">Created</div>
              <div class="meta-value">${escapeHtml(formatDate(job.createdAt))}</div>
            </div>
            <div class="meta-block">
              <div class="meta-label">Updated</div>
              <div class="meta-value">${escapeHtml(formatDate(job.updatedAt))}</div>
            </div>
          </div>
        `;

        const promptHtml = `
          <div class="job-prompt-block">
            <div class="text-card-header">
              <h3>Prompt</h3>
              <button class="copy-btn" type="button" data-copy-source="prompt-block">Copy</button>
            </div>
            <pre id="prompt-block">${escapeHtml(job.prompt)}</pre>
          </div>
        `;

        const jobErrorHtml = job.error
          ? `<div class="job-error">${escapeHtml(job.error)}</div>`
          : '';

        const filesHtml = job.files.map((file, index) => renderFileCard(job, file, index + 1)).join('');

        jobDetailsEl.innerHTML = metaHtml + forwardHtml + promptHtml + jobErrorHtml + filesHtml;
      };

      const renderFileCard = (job, file, order) => {
        const rawId = `raw-${file.id}`;
        const layoutId = `layout-${file.id}`;
        const fileInfo = [
          `Order ${order}/${job.files.length}`,
          `${(file.size / 1024).toFixed(1)} KB`,
          file.mimetype || 'unknown type',
        ].join(' · ');

        const overlayHtml = file.result && file.result.overlayBoxes && file.result.overlayBoxes.length
          ? file.result.overlayBoxes.map((box) => `
                <div class="bounding-box" style="left:${box.leftPercent}%;top:${box.topPercent}%;width:${box.widthPercent}%;height:${box.heightPercent}%;">
                  <span class="box-label">${escapeHtml(box.text)}</span>
                </div>
              `).join('')
          : '';

        const imageStage = file.result
          ? `
            <div class="image-stage">
              <img src="${file.result.imageDataUrl}" alt="${escapeHtml(file.originalname)} preview" loading="lazy" />
              <div class="box-layer">
                ${overlayHtml || ''}
              </div>
            </div>
          `
          : '<p class="text-muted mb-0">Awaiting OCR output…</p>';

        const rawTextSection = file.result?.rawText
          ? `
            <div class="text-card">
              <div class="text-card-header">
                <h5>Raw output</h5>
                <button class="copy-btn" type="button" data-copy-source="${rawId}">Copy</button>
              </div>
              <pre id="${rawId}">${escapeHtml(file.result.rawText)}</pre>
            </div>
          `
          : '';

        const layoutValue = file.result?.layoutText || '';
        const layoutSection = file.result
          ? `
            <div class="text-card">
              <div class="text-card-header">
                <h5>Layout text</h5>
                <button class="copy-btn" type="button" data-copy-source="${layoutId}">Copy</button>
              </div>
              <textarea id="${layoutId}" class="layout-textarea" data-layout-input="${file.id}" data-job-id="${job.id}" placeholder="Edit OCR layout text before sending to receipts.">${escapeHtml(layoutValue)}</textarea>
              <p class="ocr-note">Edits are kept locally and forwarded with this image.</p>
            </div>
          `
          : '';

        const fileError = file.error
          ? `<div class="file-error">${escapeHtml(file.error)}</div>`
          : '';

        return `
          <section class="file-card">
            <h4>
              <span>${escapeHtml(file.originalname || 'Image')}</span>
              <span class="status-badge ${statusClass(file.status)}">${escapeHtml(file.status)}</span>
            </h4>
            <div class="file-meta">${escapeHtml(fileInfo)}</div>
            ${imageStage}
            ${rawTextSection}
            ${layoutSection}
            ${fileError}
          </section>
        `;
      };

      const setFeedback = (message, tone = 'info') => {
        if (!feedbackEl) return;
        if (!message) {
          feedbackEl.innerHTML = '';
          return;
        }
        feedbackEl.innerHTML = `<span class="is-${tone}">${escapeHtml(message)}</span>`;
      };

      const forwardJobToReceipts = async (jobId) => {
        if (state.isForwarding) {
          return;
        }
        const job = state.jobs.find((j) => j.id === jobId);
        if (!job) {
          setFeedback('Select a job to send to receipts.', 'error');
          return;
        }
        const sendableFiles = job.files.filter((file) => file.status === 'completed' && file.result && file.result.imageDataUrl);
        if (!sendableFiles.length) {
          setFeedback('No completed OCR results to send.', 'error');
          return;
        }

        const formData = new FormData();
        let appended = 0;
        sendableFiles.forEach((file, index) => {
          const blob = dataUrlToBlob(file.result.imageDataUrl);
          if (!blob) {
            return;
          }
          appended += 1;
          const filename = file.originalname || `ocr-receipt-${index + 1}.jpg`;
          formData.append('imgs', blob, filename);
          formData.append('layout_texts', file.result.layoutText || '');
        });

        if (!appended) {
          setFeedback('Images are missing or invalid; nothing was sent.', 'error');
          return;
        }

        state.isForwarding = true;
        setFeedback(`Sending ${appended} ${appended === 1 ? 'receipt' : 'receipts'} to inbox…`, 'info');

        try {
          const response = await fetch(RECEIPT_ENDPOINT, {
            method: 'POST',
            body: formData,
            headers: { Accept: 'application/json' },
          });
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to send receipts.');
          }
          setFeedback(`Sent ${appended} ${appended === 1 ? 'receipt' : 'receipts'} to the inbox.`, 'success');
        } catch (error) {
          setFeedback(error.message || 'Failed to send receipts.', 'error');
        } finally {
          state.isForwarding = false;
        }
      };

      const handleFormSubmit = async (event) => {
        event.preventDefault();
        if (state.isSubmitting) return;
        if (!formEl) return;

        const formData = new FormData(formEl);
        state.isSubmitting = true;
        setFeedback('Queuing OCR job…', 'info');

        try {
          const response = await fetch(formEl.action, {
            method: 'POST',
            body: formData,
          });
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Failed to queue OCR job.');
          }
          setJobs(payload.jobs || [], payload.jobId);
          setFeedback('Job queued successfully.', 'success');
          if (fileInput) fileInput.value = '';
        } catch (error) {
          setFeedback(error.message || 'Failed to queue OCR job.', 'error');
        } finally {
          state.isSubmitting = false;
        }
      };

      const fetchJobs = async () => {
        if (state.isEditingLayout) {
          return;
        }
        try {
          const response = await fetch(JOBS_ENDPOINT);
          if (!response.ok) return;
          const payload = await response.json();
          if (Array.isArray(payload.jobs)) {
            setJobs(payload.jobs);
          }
        } catch (error) {
          // Silent failure, polling will retry
        }
      };

      const stopPolling = () => {
        if (state.pollTimer) {
          clearInterval(state.pollTimer);
          state.pollTimer = null;
        }
      };

      const startPolling = () => {
        if (state.pollTimer) return;
        state.pollTimer = setInterval(fetchJobs, POLL_INTERVAL);
      };

      document.addEventListener('click', (event) => {
        const target = event.target.closest('[data-copy-source]');
        if (!target) return;
        const pre = document.getElementById(target.dataset.copySource);
        if (!pre) return;
        const text = typeof pre.value === 'string' ? pre.value : (pre.textContent || '');
        navigator.clipboard.writeText(text).then(() => {
          target.textContent = 'Copied';
          setTimeout(() => {
            target.textContent = 'Copy';
          }, 1500);
        });
      });

      document.addEventListener('click', (event) => {
        const sendButton = event.target.closest('[data-send-job]');
        if (!sendButton || sendButton.disabled) return;
        sendButton.disabled = true;
        forwardJobToReceipts(sendButton.dataset.sendJob);
      });

      if (jobDetailsEl) {
        jobDetailsEl.addEventListener('input', (event) => {
          const target = event.target.closest('[data-layout-input]');
          if (!target) return;
          const fileId = target.dataset.layoutInput;
          const jobId = target.dataset.jobId;
          if (!fileId || !jobId) return;
          upsertLayoutEdit(jobId, fileId, target.value);
        });

        jobDetailsEl.addEventListener('focusin', (event) => {
          if (!event.target.closest('[data-layout-input]')) return;
          state.isEditingLayout = true;
          stopPolling();
        });

        jobDetailsEl.addEventListener('focusout', (event) => {
          if (!event.target.closest('[data-layout-input]')) return;
          state.isEditingLayout = false;
          startPolling();
          fetchJobs();
        });
      }

      if (formEl) {
        formEl.addEventListener('submit', handleFormSubmit);
      }

      if (state.jobs.length) {
        state.selectedJobId = state.jobs[0].id;
      }
      renderJobs();
      renderJobDetails();
      startPolling();
    })();
