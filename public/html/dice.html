<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3D Dice Roll Simulation</title>
    <style>
      body { margin: 0; overflow: hidden; background: #222; color: #eee; font-family: sans-serif; }
      #overlay {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 5em;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px 40px;
        border-radius: 10px;
        display: none;
      }
      #log {
        position: absolute;
        bottom: 0;
        width: 100%;
        max-height: 150px;
        overflow-y: auto;
        background: rgba(0,0,0,0.8);
        padding: 10px;
        box-sizing: border-box;
      }
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        padding: 10px;
        background: rgba(0,0,0,0.7);
        border-radius: 5px;
      }
      select { font-size: 1em; padding: 3px; }
    </style>
  </head>
  <body>
    <!-- A simple control area with the dice type selector -->
    <div id="controls">
      <label for="diceSelect">Dice Type:</label>
      <select id="diceSelect">
        <option value="4">d4</option>
        <option value="6" selected>d6</option>
        <option value="8">d8</option>
        <option value="12">d12</option>
        <option value="20">d20</option>
      </select>
      <br />
      <small>Touch/click anywhere to roll</small>
    </div>
    <!-- The overlay to show the result once the dice has come to rest -->
    <div id="overlay"></div>
    <!-- Log area -->
    <div id="log"></div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Cannon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
      // Global variables
      let scene, camera, renderer;
      let world;
      let diceMesh, diceBody;
      let floorMesh, floorBody;
      let isTouching = false;
      let rollInProgress = false;
      let resultDisplayed = false;
      let stableTimer = 0; // how long dice has been nearly still
      let throwCounter = 0;
      const STABLE_TIME_THRESHOLD = 1; // seconds
      const VELOCITY_THRESHOLD = 0.1;
      const ANGULAR_VELOCITY_THRESHOLD = 0.1;
      let lastTime;
      // Save the current dice type for geometry recreation.
      let currentDiceType = document.getElementById("diceSelect").value;
      
      // For logging:
      const logDiv = document.getElementById("log");
      // Overlay for showing the result:
      const overlay = document.getElementById("overlay");

      // Initialize Three.js
      function initThree() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 8);
        camera.lookAt(0, 0, 0);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lights:
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const directional = new THREE.DirectionalLight(0xffffff, 0.8);
        directional.position.set(5, 10, 7.5);
        scene.add(directional);

        window.addEventListener("resize", onWindowResize, false);
      }
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Initialize Cannon.js physics
      function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 16;
        world.defaultContactMaterial.friction = 0.3;
        world.defaultContactMaterial.restitution = 0.3;
      }

      // Create a floor (a simple horizontal plane)
      function createFloor() {
        // Three.js floor:
        const floorGeo = new THREE.PlaneGeometry(15, 15);
        const floorMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
        floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2;
        scene.add(floorMesh);

        // Cannon.js floor:
        const floorShape = new CANNON.Plane();
        floorBody = new CANNON.Body({ mass: 0 });
        floorBody.addShape(floorShape);
        floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(floorBody);
      }

      // Returns a Three.js geometry for the selected dice type.
      // For dice types other than d6, we use simple built‐in polyhedron geometries.
      function createDiceGeometry(diceType) {
        let geo;
        const size = 1; // overall scale
        switch (Number(diceType)) {
          case 4:
            geo = new THREE.TetrahedronGeometry(size);
            break;
          case 6:
            geo = new THREE.BoxGeometry(size, size, size);
            break;
          case 8:
            geo = new THREE.OctahedronGeometry(size);
            break;
          case 12:
            geo = new THREE.DodecahedronGeometry(size);
            break;
          case 20:
            geo = new THREE.IcosahedronGeometry(size);
            break;
          default:
            geo = new THREE.BoxGeometry(size, size, size);
        }
        return geo;
      }

      // Create a Cannon.ConvexPolyhedron from a Three.js BufferGeometry.
      // (This is a simple conversion – for robust use you may want a dedicated converter.)
      function createConvexPolyhedron(bufferGeometry) {
        // Ensure the geometry is non-indexed.
        const geo = bufferGeometry.index ? bufferGeometry.toNonIndexed() : bufferGeometry;
        const positions = geo.attributes.position.array;
        const vertices = [];
        for (let i = 0; i < positions.length; i += 3) {
          vertices.push(new CANNON.Vec3(positions[i], positions[i + 1], positions[i + 2]));
        }
        // Construct faces: every consecutive group of 3 vertices makes one face.
        const faces = [];
        for (let i = 0; i < vertices.length; i += 3) {
          faces.push([i, i + 1, i + 2]);
        }
        return new CANNON.ConvexPolyhedron({ vertices, faces });
      }

      // Create a new dice (both Three.js mesh and Cannon.js body) and add to scene/world.
      function createDice(diceType) {
        currentDiceType = diceType;
        if (diceMesh) scene.remove(diceMesh);
        if (diceBody) world.remove(diceBody);

        const geometry = createDiceGeometry(diceType);
        // Use a simple MeshPhongMaterial with a random color.
        const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
        diceMesh = new THREE.Mesh(geometry, material);
        scene.add(diceMesh);

        // Create corresponding physics body.
        const shape = createConvexPolyhedron(geometry);
        diceBody = new CANNON.Body({ mass: 300, angularDamping: 0.1, linearDamping: 0.1 });
        diceBody.addShape(shape);
        // Start the dice above the floor.
        diceBody.position.set(0, 4, 0);
        diceBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.random() * Math.PI * 2);
        world.addBody(diceBody);
      }

      // Called when the user starts touching/clicking the screen.
      function onPointerDown(event) {
        // If a dice throw is already in progress, ignore new touches.
        if (rollInProgress || resultDisplayed) return;
        isTouching = true;
        rollInProgress = true;
        stableTimer = 0;
        // (Re)create the dice using the current type (selected in the drop‐down).
        let diceType = document.getElementById("diceSelect").value;
        createDice(diceType);
        // Reset velocities:
        diceBody.velocity.set(0, 0, 0);
        diceBody.angularVelocity.set(0, 0, 0);
      }
      // Called when the user releases the touch/click.
      function onPointerUp(event) {
        isTouching = false;
      }
      // Also allow a screen click to dismiss the result overlay for the next throw.
      function onDocumentClick(event) {
        if (resultDisplayed) {
          overlay.style.display = "none";
          resultDisplayed = false;
          // Ready for a new roll.
        }
      }

      // Determine the dice result by finding the face whose (local) centroid points most upward.
      // (This simple method works for our convex dice geometries.)
      function getDiceResult() {
        // For the physics shape (a ConvexPolyhedron), loop over its faces.
        const shape = diceBody.shapes[0];
        let bestDot = -Infinity;
        let bestFace = -1;
        // World up vector:
        const up = new CANNON.Vec3(0, 1, 0);
        for (let i = 0; i < shape.faces.length; i++) {
          const faceIndices = shape.faces[i];
          let faceCenter = new CANNON.Vec3(0, 0, 0);
          faceIndices.forEach((index) => {
            faceCenter = faceCenter.vadd(shape.vertices[index]);
          });
          faceCenter = faceCenter.scale(1 / faceIndices.length);
          // Rotate the face center by the dice’s current orientation.
          let worldFace = diceBody.quaternion.vmult(faceCenter);
          // Dot product with world up:
          let dot = worldFace.dot(up);
          if (dot > bestDot) {
            bestDot = dot;
            bestFace = i;
          }
        }
        // For simplicity, assign the result as (bestFace index + 1).
        return bestFace + 1;
      }

      // The main update loop.
      function animate(time) {
        requestAnimationFrame(animate);
        if (!lastTime) lastTime = time;
        const dt = (time - lastTime) / 1000;
        lastTime = time;

        // Only when rolling is in progress do we update the dice motion.
        // If the user is touching, add some extra random torque.
        if (rollInProgress && isTouching) {
          diceBody.torque.x += (Math.random() - 0.5) * 50;
          diceBody.torque.y += (Math.random() - 0.5) * 50;
          diceBody.torque.z += (Math.random() - 0.5) * 50;
        }

        world.step(1 / 60, dt, 3);

        // Sync the Three.js dice mesh with the Cannon.js dice body.
        if (diceMesh && diceBody) {
          diceMesh.position.copy(diceBody.position);
          diceMesh.quaternion.copy(diceBody.quaternion);
        }

        // Check if the dice has come to a near-stop.
        if (rollInProgress && !isTouching && diceBody) {
          const lv = diceBody.velocity;
          const av = diceBody.angularVelocity;
          if (lv.length() < VELOCITY_THRESHOLD && av.length() < ANGULAR_VELOCITY_THRESHOLD) {
            stableTimer += dt;
            if (stableTimer > STABLE_TIME_THRESHOLD) {
              // Consider the dice settled: decide result.
              const result = getDiceResult();
              throwCounter++;
              overlay.innerText = result;
              overlay.style.display = "block";
              resultDisplayed = true;
              rollInProgress = false;
              logResult(throwCounter, currentDiceType, result);
            }
          } else {
            stableTimer = 0;
          }
        }
        renderer.render(scene, camera);
      }

      // Append a new log entry.
      function logResult(throwNum, diceType, result) {
        const p = document.createElement("p");
        p.innerText = "Throw " + throwNum + " (" + "d" + diceType + "): " + result;
        logDiv.appendChild(p);
        // Auto-scroll log:
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      // Set up event listeners.
      function initEvents() {
        renderer.domElement.addEventListener("pointerdown", onPointerDown);
        renderer.domElement.addEventListener("pointerup", onPointerUp);
        document.addEventListener("click", onDocumentClick);
      }

      // Initialize everything.
      function init() {
        initThree();
        initCannon();
        createFloor();
        initEvents();
        animate();
      }
      init();
    </script>
  </body>
</html>
